#!/usr/bin/env perl
use strict;
use warnings;

use File::Copy;
use IPC::Open3;
use IO::Select;
use Time::HiRes qw/usleep alarm/;

my $path       = "img/heater_b/";
my $file_dump  = "dump.jpg";
my $cap_cmd    = "gphoto2 --shell --filename \"$file_dump\"";
my $cap_timeout= 60;
my $delay      = 15; # Lowest realistic delay on USB1.1 w/ large files
my $seq        = 1;

my $pid;
my $sel;
my $captured;

my @cmd_init = ('set-config capture=1',       # Capture mode (must be first config opt)
	        'set-config imagequality=2',  # Superfine
	        'set-config imagesize=0',     # 0=Large 1=Med1 2=Med2 3=Small
		'set-config whitebalance=0',  # Auto
		'set-config photoeffect=0',   # 0=None
		'set-config capturetarget=0', # 0=RAM, 1=CF
		'set-config flashmode=0',     # 0=Off 1=Auto 2=On 3=Fill 4=Auto
		'set-config zoom=6',
		'set-config meteringmode=1',  # 0=Center 1=Spot 2=Evaluative
		'set-config focusingpoint=0', # Center 
		'set-config afdistance=0',    # 0=Auto 1=Near 2=Far
		'set-config assistlight=1',   # 0=Off 1=On
		'set-config shutterspeed=0',  # 0=Auto
		'set-config iso=4',           # 4=Auto
		'set-config aperture=0');     # Auto

my @cmd_shot = ('set-config focuslock=1',     # 0=Lock 1=Unlock
                'capture-image-and-download');

sub canon_send_seq {

	my ($sel, @cmds) = @_;

	my $t_beg = time();

	foreach my $cmd (@cmds) {

		print "<< $cmd\n";
		print WRITE "$cmd\n";

		my $read = 0;
		while($read == 0) {

		      my @ready = $$sel->can_read;

		      foreach my $h (@ready) {
			      my $buf = '';
			      if ($h eq \*ERROR) {
				      sysread(ERROR, $buf, 4096);
				      $read++;
				      if($buf) {
					      print "\e[36m>> $buf\e[39m"
				      }
			      } else {
				      sysread(READ, $buf, 4096);
				      $read++;
				      if($buf) { 
					      print "\e[36m>> $buf\e[39m"
				      } 
			      }
		      }
		}
	}

	my $t_end = time();

	my $t_duration = $t_end - $t_beg;

	printf("* Sequence took %d seconds\n",
		$t_duration);


}

sub stop {
    $SIG{INT} = \&stop;
    canon_send_seq(\$sel, 'quit');
    waitpid($pid, 0);
    exit;
}

sub capture_timeout {
    $SIG{ALRM} = \&capture_timeout;
    $captured = 0;
    print "* Capture timed out!\n";
}

$SIG{INT} = \&stop;
$SIG{ALRM} = \&capture_timeout;

die "* Destination path \"$path\" doesn't exist.\n\n" if ! -d $path;

$sel = new IO::Select();
$pid = open3(\*WRITE, \*READ,\*ERROR, $cap_cmd);

$sel->add(\*READ);
$sel->add(\*ERROR);

print "* Initializing\n";
canon_send_seq(\$sel, @cmd_init);

for(;;) {

	my $t_beg = time();

	print "* Capturing\n";
	canon_send_seq(\$sel, @cmd_shot);
 
	alarm($cap_timeout);
	printf("* Waiting for captured image\n");
	$captured = 1;
	while($captured) {
		if(-f $file_dump) {
			$captured = 0;
			next;
		}
		usleep(100000);
	}
	alarm(0);

	my $file_dst = sprintf("%s/cap_%06d.jpg", $path, $seq);

	if(! move($file_dump, $file_dst)) {
		# FIXME This might turn out to be fatal if the pipe died
		printf("\e[31m* Error: move \"%s\" -> \"%s\" failed\e[39m\n",
		       $file_dump, 
		       $file_dst);
#	       print "* Re-initializing\n";
#	       my $t_beg = time();
#	       canon_send_seq(\$sel, @cmd_init);
	} else {
		printf("\e[32m* Stored \"%s\"\e[39m\n",
		       $file_dst);
	       $seq++;
	}

	my $t_end = time();
	my $t_duration = $t_end - $t_beg;
	my $t_remain = $t_duration - $delay;

	print "* Capture took $t_duration seconds\n";
	if($t_remain > 0) {
		print "\e[33m* $t_remain seconds behind!\e[39m\n";
	} elsif($t_remain < 0) {
		$t_remain = abs($t_remain);
		print "* $t_remain seconds until next capture\n";
		sleep($t_remain);
	}

}
